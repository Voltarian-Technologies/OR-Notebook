<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>OR Notebook â€” Modern</title>

<!-- PWA manifest & icons -->
<link rel="manifest" href="manifest.json">
<link rel="icon" href="favicon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="favicon.svg">

<!-- Unified stylesheet -->
<link rel="stylesheet" href="/styles.css">

<!-- Marked.js for markdown parsing -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<!-- DOMPurify for sanitizing HTML produced by marked -->
<script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>

<meta name="theme-color" content="#f5f7fb" id="themeColorMeta">
</head>
<body>
  <div class="header">
    <div style="display:flex;align-items:center;gap:12px">
      <button id="mobileFoldersBtn" class="mobile-folders-btn" aria-label="Toggle folders">â˜°</button>
      <h1 style="margin:0;font-size:18px">OR Notebook</h1>
    </div>
    <div style="display:flex;align-items:center;gap:8px">
      <a id="settingsLink" href="/settings" class="btn" title="Settings">âš™ Settings</a>
    </div>
  </div>

  <div class="container">
    <aside class="sidebar" id="sidebar">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <strong>Folders</strong>
        <div style="font-size:12px;color:var(--muted-text)" id="folderCount">0</div>
      </div>

      <div id="folderList" class="folder-list" aria-label="Folders"></div>

      <button id="addFolder" class="folder-add">+ Add Folder</button>
    </aside>

    <main class="main">
      <div class="toolbar">
        <input id="search" class="search" placeholder="Search notes, tags, titles..." aria-label="Search notes" />
        <div class="tag-filter" id="tagFilter" aria-label="Tag filters"></div>
        <button id="newNoteBtn" class="btn">New Note</button>
      </div>

      <div class="editor" role="region" aria-label="Editor area">
        <div class="editor-left">
          <div class="toolbar-md" role="toolbar" aria-label="Formatting">
            <button class="md-btn" data-action="bold" title="Bold">B</button>
            <button class="md-btn" data-action="italic" title="Italic">I</button>
            <button class="md-btn" data-action="h1" title="Heading">H1</button>
            <button class="md-btn" data-action="code" title="Inline code">{ }</button>
            <button class="md-btn" data-action="ul" title="Unordered list">â€¢ List</button>
            <button class="md-btn" data-action="link" title="Link">Link</button>
          </div>
          <input id="noteTitle" class="title-input" placeholder="Note title" aria-label="Note title" />
          <textarea id="noteBody" class="textarea" placeholder="Write your note using Markdown..." aria-label="Note body"></textarea>
          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <input id="tagInput" placeholder="Add tags (comma separated)" style="flex:1;padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text)" aria-label="Tags" />
            <button id="saveNote" class="btn">Save</button>
          </div>
        </div>

        <aside class="editor-right">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <strong>Preview</strong>
            <div style="font-size:12px;color:var(--muted-text)">Rendered Markdown</div>
          </div>
          <div id="preview" class="preview" aria-live="polite"></div>

          <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center">
            <strong>Notes in "<span id="currentFolderName">General</span>"</strong>
            <div style="font-size:12px;color:var(--muted-text)" id="notesCount">0</div>
          </div>

          <div id="notesGrid" class="notes-grid" draggable="false" aria-label="Notes"></div>
        </aside>
      </div>
    </main>
  </div>

  <!-- modal -->
  <div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" style="display:none">
    <div class="modal" role="document">
      <div id="modalMessage" class="message"></div>
      <div class="actions">
        <button id="modalCancel" class="modal-btn">Cancel</button>
        <button id="modalOk" class="modal-btn primary">OK</button>
      </div>
    </div>
  </div>
<script>
/* Inline app script remains (folders, notes, preview, etc.)
   I removed the theme toggle logic here; theme is applied by app.js to centralize behavior.
   Note: app.js is loaded after this script and will apply the stored theme and listen for changes.
*/

/* helpers */
const uid = (p='n')=>p+'_'+Math.random().toString(36).slice(2,9);
const qs = s => document.querySelector(s);
const qsa = s => Array.from(document.querySelectorAll(s));

/* DOM refs */
const folderList = qs('#folderList');
const addFolderBtn = qs('#addFolder');
const folderCountEl = qs('#folderCount');
const newNoteBtn = qs('#newNoteBtn');
const noteTitle = qs('#noteTitle');
const noteBody = qs('#noteBody');
const saveNoteBtn = qs('#saveNote');
const notesGrid = qs('#notesGrid');
const preview = qs('#preview');
const notesCount = qs('#notesCount');
const currentFolderName = qs('#currentFolderName');
const searchInput = qs('#search');
const tagInput = qs('#tagInput');
const tagFilter = qs('#tagFilter');
const mobileFoldersBtn = qs('#mobileFoldersBtn');
const sidebar = qs('#sidebar');

const modalBackdrop = qs('#modalBackdrop');
const modalMessage = qs('#modalMessage');
const modalOk = qs('#modalOk');
const modalCancel = qs('#modalCancel');
const themeColorMeta = document.getElementById('themeColorMeta');

/* storage helpers */
function loadFolders(){
  try {
    const raw = localStorage.getItem('or_folders');
    const arr = raw ? JSON.parse(raw) : null;
    if(!arr || !Array.isArray(arr) || arr.length === 0){
      const base = [{id:'f_general',name:'General'}];
      localStorage.setItem('or_folders', JSON.stringify(base));
      return base;
    }
    return arr;
  } catch(e) {
    const base = [{id:'f_general',name:'General'}];
    localStorage.setItem('or_folders', JSON.stringify(base));
    return base;
  }
}
function saveFolders(f){ localStorage.setItem('or_folders', JSON.stringify(f)); }
function loadNotesMap(){ try { const raw = localStorage.getItem('or_notes'); return raw?JSON.parse(raw):{}; } catch(e) { return {}; } }
function saveNotesMap(map){ localStorage.setItem('or_notes', JSON.stringify(map)); }

let folders = loadFolders();
let notesMap = loadNotesMap();
let currentFolderId = localStorage.getItem('or_currentFolder') || (folders[0] && folders[0].id);
if(!currentFolderId || !folders.find(f => f.id === currentFolderId)) currentFolderId = (folders[0] && folders[0].id);

/* expanded state */
function loadExpandedState(){ try{ const raw = localStorage.getItem('or_expandedFolders'); const arr = raw ? JSON.parse(raw) : []; return new Set(Array.isArray(arr)?arr:[]); }catch(e){ return new Set(); } }
function saveExpandedState(){ try{ localStorage.setItem('or_expandedFolders', JSON.stringify(Array.from(expandedFolders))); }catch(e){} }
const expandedFolders = loadExpandedState();

/* escape html */
function escapeHtml(s){
  if(s === null || s === undefined) return '';
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c]));
}

/* modal confirm */
function showConfirm(message){
  return new Promise(resolve => {
    modalMessage.textContent = message;
    modalBackdrop.style.display = 'flex';
    modalOk.focus();
    function clean(result){
      modalBackdrop.style.display = 'none';
      modalOk.removeEventListener('click', onOk);
      modalCancel.removeEventListener('click', onCancel);
      modalBackdrop.removeEventListener('keydown', onKey);
      resolve(result);
    }
    function onOk(){ clean(true); }
    function onCancel(){ clean(false); }
    function onKey(e){ if(e.key === 'Escape') onCancel(); if(e.key === 'Enter') onOk(); }
    modalOk.addEventListener('click', onOk);
    modalCancel.addEventListener('click', onCancel);
    modalBackdrop.addEventListener('keydown', onKey);
  });
}

/* configure marked */
marked.setOptions({ gfm:true, breaks:false, headerIds:true, mangle:false });

function renderPreview(){
  const md = noteBody.value || '';
  if(!md){ preview.innerHTML = '<em style="color:var(--muted-text)">Empty</em>'; return; }
  try {
    const raw = marked.parse(md);
    preview.innerHTML = DOMPurify.sanitize(raw, {USE_PROFILES: {html:true}});
  } catch(e){
    preview.innerHTML = '<pre>' + escapeHtml(md) + '</pre>';
  }
}

/* inline editor handling */
let currentInlineEditor = null;
function cancelInlineEditor(){
  if(!currentInlineEditor) return;
  const { el, input, folderObj, original, isNew } = currentInlineEditor;
  try {
    if(isNew){ if(el && el.parentNode) el.parentNode.removeChild(el); }
    else { if(el){ const nameDiv = el.querySelector('.name'); if(nameDiv) nameDiv.textContent = original || (folderObj && folderObj.name) || ''; } }
  } catch(e){}
  currentInlineEditor = null;
}

/* open note from sidebar */
function openNoteGlobally(folderId, noteId){
  if(!folders.find(f=>f.id===folderId)) return;
  currentFolderId = folderId; localStorage.setItem('or_currentFolder', currentFolderId);
  updateFolderHeader(); renderFolders(); loadNotes();
  const arr = notesMap[folderId] || []; const n = arr.find(x=>x.id===noteId);
  if(n){ noteTitle.value = n.title; noteBody.value = n.text; tagInput.value = (n.tags||[]).join(', '); saveNoteBtn.setAttribute('data-editing', noteId); renderPreview(); scrollToTop(); }
}

/* render folders */
function renderFolders(){
  folderList.innerHTML = '';
  folders.forEach((f,idx) => {
    const el = document.createElement('div');
    el.className = 'folder' + (f.id === currentFolderId ? ' active' : '');
    el.draggable = true;
    el.dataset.id = f.id;

    const row = document.createElement('div'); row.className='folder-row';

    const toggle = document.createElement('button'); toggle.className='folder-toggle';
    const isExpanded = expandedFolders.has(f.id);
    if(isExpanded) toggle.classList.add('expanded');
    toggle.innerHTML = 'â–¸'; toggle.setAttribute('aria-expanded', String(isExpanded));
    toggle.addEventListener('click', e=>{ e.stopPropagation(); if(expandedFolders.has(f.id)) expandedFolders.delete(f.id); else expandedFolders.add(f.id); saveExpandedState(); renderFolders(); });

    const nameDiv = document.createElement('div'); nameDiv.className='name'; nameDiv.textContent = f.name;
    const countDiv = document.createElement('div'); countDiv.className='count'; countDiv.textContent = (notesMap[f.id]||[]).length;

    const actions = document.createElement('div'); actions.className='folder-actions';
    const renameBtn = document.createElement('button'); renameBtn.setAttribute('title','Rename'); renameBtn.setAttribute('data-act','rename'); renameBtn.innerHTML='âœŽ';
    const deleteBtn = document.createElement('button'); deleteBtn.setAttribute('title','Delete'); deleteBtn.setAttribute('data-act','delete'); deleteBtn.innerHTML='ðŸ—‘';
    const grabDiv = document.createElement('div'); grabDiv.className='grab'; grabDiv.title='Drag to reorder'; grabDiv.innerHTML='â˜°';
    actions.appendChild(renameBtn); actions.appendChild(deleteBtn); actions.appendChild(grabDiv);

    row.appendChild(toggle); row.appendChild(nameDiv); row.appendChild(countDiv); row.appendChild(actions);
    el.appendChild(row);

    // notes under folder
    const notesContainer = document.createElement('div'); notesContainer.className = 'folder-notes' + (isExpanded ? ' show' : '');
    const notesArr = (notesMap[f.id] || []).slice().reverse();
    notesArr.forEach(n => {
      const noteRow = document.createElement('div'); noteRow.className='folder-note';
      const t = document.createElement('div'); t.className='title'; t.textContent = n.title || 'Untitled';
      const m = document.createElement('div'); m.className='meta'; m.textContent = new Date(n.updated || n.created).toLocaleDateString();
      noteRow.appendChild(t); noteRow.appendChild(m);
      noteRow.addEventListener('click', ev=>{ ev.stopPropagation(); openNoteGlobally(f.id, n.id); if(window.innerWidth <= 900) document.body.classList.remove('show-sidebar'); });
      notesContainer.appendChild(noteRow);
    });
    el.appendChild(notesContainer);

    // click selects folder
    el.addEventListener('click', (e)=>{ const act = e.target && e.target.dataset && e.target.dataset.act; if(act) return; selectFolder(f.id); });

    // rename inline
    renameBtn.addEventListener('click',(e)=>{ e.stopPropagation(); startInlineFolderRename(el,f); });

    // delete with modal
    deleteBtn.addEventListener('click', async (e)=>{ e.stopPropagation(); const ok = await showConfirm('Delete folder "'+f.name+'" and its notes?'); if(!ok) return; delete notesMap[f.id]; folders = folders.filter(x=>x.id!==f.id); if(expandedFolders.has(f.id)){ expandedFolders.delete(f.id); saveExpandedState(); } if(!folders.length) folders=[{id:'f_general',name:'General'}]; if(currentFolderId===f.id) currentFolderId = folders[0].id; saveFolders(folders); saveNotesMap(notesMap); renderFolders(); loadNotes(); updateTagFilters(); });

    // dragging
    el.addEventListener('dragstart', ev=>{ ev.dataTransfer.setData('text/plain', f.id); ev.dataTransfer.effectAllowed='move'; el.classList.add('dragging'); });
    el.addEventListener('dragend', ()=> el.classList.remove('dragging'));
    el.addEventListener('dragover', ev=>{ ev.preventDefault(); el.classList.add('drag-over'); });
    el.addEventListener('dragleave', ()=> el.classList.remove('drag-over'));
    el.addEventListener('drop', ev=>{
      ev.preventDefault(); el.classList.remove('drag-over');
      const src = ev.dataTransfer.getData('text/plain');
      if(src){
        const srcIdx = folders.findIndex(x=>x.id===src);
        const tgtIdx = folders.findIndex(x=>x.id===f.id);
        if(srcIdx>-1){ const [m]=folders.splice(srcIdx,1); folders.splice(tgtIdx,0,m); saveFolders(folders); renderFolders(); return; }
      }
      const noteData = ev.dataTransfer.getData('application/x-note');
      if(noteData){ try{ const n = JSON.parse(noteData); moveNoteBetweenFolders(n.id,n.fromFolderId,f.id); expandedFolders.add(f.id); saveExpandedState(); renderFolders(); }catch(e){} }
    });

    folderList.appendChild(el);
  });

  folderCountEl.textContent = folders.length;
  updateFolderHeader();
}

/* inline rename */
function startInlineFolderRename(folderEl, folderObj){
  cancelInlineEditor();
  const nameDiv = folderEl.querySelector('.name');
  const original = folderObj.name;
  const input = document.createElement('input'); input.type='text'; input.className='folder-edit-input'; input.value = original; input.setAttribute('aria-label','Rename folder');
  nameDiv.textContent=''; nameDiv.appendChild(input); input.focus(); input.select();
  currentInlineEditor = { el: folderEl, input, folderObj, original, isNew:false };
  function commit(){ const v=input.value.trim(); if(!v){ cancelInlineEditor(); renderFolders(); return; } folderObj.name=v; saveFolders(folders); currentInlineEditor=null; renderFolders(); }
  function onKey(e){ if(e.key==='Enter'){ commit(); } else if(e.key==='Escape'){ cancelInlineEditor(); renderFolders(); } }
  function onBlur(){ const v=input.value.trim(); if(v) commit(); else { cancelInlineEditor(); renderFolders(); } }
  input.addEventListener('keydown', onKey); input.addEventListener('blur', onBlur);
}

/* create new folder */
function startInlineNewFolder(){
  let base='New folder', suffix=1, name=base;
  const exists = n => folders.some(f=>f.name===n);
  while(exists(name)){ suffix++; name = base + ' ' + suffix; }
  const id = uid('f'); const f = { id, name };
  folders.push(f); saveFolders(folders); currentFolderId = id; localStorage.setItem('or_currentFolder', id);
  expandedFolders.add(id); saveExpandedState();
  renderFolders();
  const createdEl = folderList.querySelector(`.folder[data-id="${id}"]`);
  if(createdEl){ startInlineFolderRename(createdEl, f); if(window.innerWidth <= 900) document.body.classList.add('show-sidebar'); }
}

/* notes rendering */
let notesRenderTimer = null;
function loadNotes(){
  notesGrid.classList.remove('fade-enter'); notesGrid.classList.add('fade-leave');
  clearTimeout(notesRenderTimer);
  notesRenderTimer = setTimeout(()=>{
    notesGrid.classList.remove('fade-leave'); notesGrid.innerHTML='';
    const arr = (notesMap[currentFolderId]||[]).slice().reverse();
    const q = (searchInput.value||'').trim().toLowerCase();
    const activeTags = Array.from(document.querySelectorAll('.tag-pill.active')).map(el=>el.textContent);
    const filtered = arr.filter(n=>{ const byQ = !q || (n.title||'').toLowerCase().includes(q) || (n.text||'').toLowerCase().includes(q) || ((n.tags||[]).join(' ')).toLowerCase().includes(q); const byTag = activeTags.length===0 || (n.tags||[]).some(t=>activeTags.includes(t)); return byQ && byTag; });
    filtered.forEach(n=>{
      const card=document.createElement('div'); card.className='note-card'; card.draggable=true; card.dataset.id=n.id;
      const excerpt=(n.text||'').slice(0,140);
      card.innerHTML = `<div><div class="note-title">${escapeHtml(n.title||'Untitled')}</div><div class="note-body" style="color:var(--muted-text);font-size:13px">${escapeHtml(excerpt)}${(n.text||'').length>140?'â€¦':''}</div></div><div class="note-meta"><div style="display:flex;gap:8px;align-items:center"><div style="font-size:12px;color:var(--muted-text)">${new Date(n.updated||n.created).toLocaleString()}</div></div><div class="note-actions"><button class="small-btn" data-act="open">Open</button><button class="small-btn" data-act="delete">Delete</button></div></div><div class="note-tags">${(n.tags||[]).map(t=>`<span class="note-tag">${escapeHtml(t)}</span>`).join('')}</div>`;
      card.querySelector('[data-act="open"]').addEventListener('click', ()=>openNoteForEdit(n.id));
      card.querySelector('[data-act="delete"]').addEventListener('click', async ()=>{ const ok = await showConfirm('Delete note "'+(n.title||'Untitled')+'"?' ); if(!ok) return; const arrAll = notesMap[currentFolderId]||[]; const idx = arrAll.findIndex(x=>x.id===n.id); if(idx>-1){ arrAll.splice(idx,1); saveNotesMap(notesMap); loadNotes(); updateTagFilters(); } });
      card.addEventListener('dblclick', ()=>openNoteForEdit(n.id));
      card.addEventListener('dragstart', ev=>{ card.classList.add('dragging'); try{ ev.dataTransfer.setData('application/x-note', JSON.stringify({ id:n.id, fromFolderId: currentFolderId })); }catch(e){} ev.dataTransfer.effectAllowed='move'; });
      card.addEventListener('dragend', ()=>card.classList.remove('dragging'));
      notesGrid.appendChild(card);
    });
    notesCount.textContent = (notesMap[currentFolderId]||[]).length;
    renderFolders();
    notesGrid.classList.add('fade-enter'); setTimeout(()=>notesGrid.classList.remove('fade-enter'),380);
  },120);
}

/* CRUD */
function createNote(){
  if(!currentFolderId) return;
  const title = (noteTitle.value||'').trim() || ((noteBody.value||'').split('\n')[0]||'').slice(0,40) || 'Untitled';
  const tags = parseTags(tagInput.value);
  const id = uid('note');
  const note = { id, title, text: noteBody.value||'', tags, created: Date.now(), updated: Date.now() };
  if(!notesMap[currentFolderId]) notesMap[currentFolderId]=[];
  notesMap[currentFolderId].push(note);
  saveNotesMap(notesMap);
  noteTitle.value=''; noteBody.value=''; tagInput.value='';
  loadNotes(); updateTagFilters(); noteBody.focus();
}
function openNoteForEdit(noteId){
  const arr = notesMap[currentFolderId]||[]; const n = arr.find(x=>x.id===noteId); if(!n) return;
  noteTitle.value=n.title; noteBody.value=n.text; tagInput.value=(n.tags||[]).join(', '); saveNoteBtn.setAttribute('data-editing', noteId); renderPreview(); scrollToTop();
}
function updateNoteFromEditor(){
  const editing = saveNoteBtn.getAttribute('data-editing'); const tags = parseTags(tagInput.value);
  if(editing){
    const arr = notesMap[currentFolderId]||[]; const idx = arr.findIndex(x=>x.id===editing);
    if(idx>-1){ arr[idx].title = noteTitle.value || arr[idx].title; arr[idx].text = noteBody.value || ''; arr[idx].tags = tags; arr[idx].updated = Date.now(); saveNotesMap(notesMap); saveNoteBtn.removeAttribute('data-editing'); }
    else { createNote(); saveNoteBtn.removeAttribute('data-editing'); }
  } else { createNote(); }
  loadNotes(); updateTagFilters();
}
saveNoteBtn.addEventListener('click', ()=> updateNoteFromEditor());

function parseTags(s){ if(!s) return []; return s.split(',').map(x=>x.trim()).filter(Boolean).slice(0,10); }

/* move notes */
function moveNoteBetweenFolders(noteId, fromFolderId, toFolderId){
  if(fromFolderId===toFolderId) return;
  const from = notesMap[fromFolderId]||[]; const idx = from.findIndex(x=>x.id===noteId);
  if(idx===-1) return;
  const [note] = from.splice(idx,1);
  if(!notesMap[toFolderId]) notesMap[toFolderId]=[];
  notesMap[toFolderId].push(note);
  saveNotesMap(notesMap);
  expandedFolders.add(toFolderId); saveExpandedState();
  loadNotes(); updateTagFilters();
}

/* drop handlers already added earlier for folderList */

/* toolbar actions already wired earlier */
qsa('.md-btn').forEach(btn => btn.addEventListener('click', ()=>{ applyMdAction(btn.dataset.action); }));
function applyMdAction(action){
  const ta = noteBody; const start = ta.selectionStart, end = ta.selectionEnd; const val = ta.value; const selected = val.slice(start,end) || 'text';
  let rep = '';
  switch(action){
    case 'bold': rep = `**${selected}**`; break;
    case 'italic': rep = `*${selected}*`; break;
    case 'h1': rep = `# ${selected}`; break;
    case 'code': rep = '`'+selected+'`'; break;
    case 'ul': rep = selected.split('\n').map(l=>l.trim()?'- '+l:l).join('\n'); break;
    case 'link': rep = `[${selected}](https://)`; break;
    default: rep = selected;
  }
  ta.setRangeText(rep, start, end, 'end'); ta.focus(); renderPreview();
}

noteBody.addEventListener('input', renderPreview);
noteTitle.addEventListener('input', renderPreview);

/* tag filters */
function updateTagFilters(){
  const allNotes = Object.values(notesMap).flat().filter(Boolean); const tagSet = new Set();
  allNotes.forEach(n => (n.tags||[]).forEach(t=>tagSet.add(t)));
  const tags = Array.from(tagSet).sort(); tagFilter.innerHTML='';
  if(tags.length===0){ const el=document.createElement('div'); el.style.color='var(--muted-text)'; el.style.fontSize='13px'; el.textContent='No tags'; tagFilter.appendChild(el); return; }
  tags.forEach(t=>{ const el=document.createElement('button'); el.className='tag-pill'; el.textContent=t; el.title='Filter by tag'; el.addEventListener('click',()=>{ el.classList.toggle('active'); loadNotes(); }); tagFilter.appendChild(el); });
}

/* new note */
newNoteBtn.addEventListener('click', ()=>{ noteTitle.value=''; noteBody.value=''; tagInput.value=''; saveNoteBtn.removeAttribute('data-editing'); noteBody.focus(); renderPreview(); });

/* search */
searchInput.addEventListener('input', ()=> loadNotes());

/* helpers */
function scrollToTop(){ window.scrollTo({top:0,behavior:'smooth'}); }

/* initial render */
renderFolders(); loadNotes(); updateTagFilters(); renderPreview();

/* persist state on unload */
window.addEventListener('beforeunload', ()=>{ saveFolders(folders); saveNotesMap(notesMap); localStorage.setItem('or_currentFolder', currentFolderId); saveExpandedState(); });

/* select folder */
function selectFolder(id){ if(!folders.find(f=>f.id===id)) return; currentFolderId=id; localStorage.setItem('or_currentFolder', id); updateFolderHeader(); renderFolders(); loadNotes(); }

/* add folder click */
addFolderBtn.addEventListener('click', (e)=>{ e.preventDefault(); startInlineNewFolder(); });

/* mobile toggle */
mobileFoldersBtn.addEventListener('click', ()=>{ document.body.classList.toggle('show-sidebar'); });

/* drop note on main area */
document.addEventListener('dragover', ev=>ev.preventDefault());
document.addEventListener('drop', ev=>{
  const d = ev.dataTransfer.getData('application/x-note'); if(!d) return;
  try{ const noteObj = JSON.parse(d); const targetFolder = document.elementFromPoint(ev.clientX, ev.clientY)?.closest('.folder'); if(!targetFolder){ if(noteObj.fromFolderId && noteObj.fromFolderId !== currentFolderId) moveNoteBetweenFolders(noteObj.id, noteObj.fromFolderId, currentFolderId); } }catch(e){}
});

/* inline editor cancellation click-away */
document.addEventListener('click', (e)=>{ if(!currentInlineEditor) return; const { input, el } = currentInlineEditor; if(!input) return; if(e.target===input) return; if(el.contains(e.target)) return; input.blur(); });

/* update folder header */
function updateFolderHeader(){ const f = folders.find(x=>x.id===currentFolderId); currentFolderName.textContent = f ? f.name : '(none)'; }

/* Expose small API for debugging */
window.orNotebook = { folders, notesMap, renderFolders, loadNotes, expandedFolders };

/* Service worker registration (simple offline caching) */
if('serviceWorker' in navigator){
  window.addEventListener('load', ()=> {
    navigator.serviceWorker.register('service-worker.js').then(reg=>{
      console.log('ServiceWorker registered', reg.scope);
    }).catch(err=>{
      console.warn('ServiceWorker failed to register', err);
    });
  });
}
</script>

<!-- Enhancement & offline autocomplete + theme script -->
<script src="/app.js"></script>

</body>
</html>